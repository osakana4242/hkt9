<!DOCTYPE html>
<html lang="ja">

	<head>
		<meta charset="utf-8">
		<title>Sample_GoogleMap</title>

		<script src="https://maps.google.com/maps/api/js?key=AIzaSyCevgHCSZ33IRBJzRhuZPWQ0XL8o-iOrng&language=ja"></script>

		<style>
			html { height: 100% }
			body { height: 100% }
			#map {
				height: 480px;
				width: 640px;
			}
		</style>
	</head>

	<body>
		<div id="info">
			うんこ
		</div>
		<div id="map"></div>

		<script>

			class Ticker {
				constructor() {
					this.frameCount = 0;
					this.deltaTime = 0;
					this.time = 0;
				}

				static next(ticker, deltaTime) {
					const n = new Ticker();
					n.frameCount = ticker.frameCount + 1;
					n.deltaTime = deltaTime;
					n.time = ticker.time + deltaTime;
					return n;
				}
			}

			class Time {
				static secToTime(sec) {
					return parseInt(sec * 1000);
				}
				static msecToTime(sec) {
					return parseInt(sec);
				}
			}

			class MathUtil {
				static progress01(a, b) {
					if (b <= 0) return 1;
					return a / b;
				}
				static lerp(a, b, t) {
					return a + (b - a) * t;
				}
				static lerpAngle(a, b, t) {
					const diff1 = b - a;
					if (Math.abs(diff1) < 180) {
						return a + diff1 * t;
					}

					const diff2 = MathUtil.normalizeDeltaAngle(diff1);
					return a + diff2 * t;
				}
				static deltaAngle(a, b) {
					return MathUtil.normalizeDeltaAngle(b - a);
				}
				static distanceAngle(a, b) {
					return Math.abs(MathUtil.deltaAngle(a, b))
				}
				static normalizeDeltaAngle(diff1) {
					const diff2 = (0 < diff1) ?
						- (360 - diff1) :
						- (diff1 - 360);
					return diff2;
				}
			}

			class LatLngUtil {
				static lerp(a, b, t) {
					return new google.maps.LatLng(
						MathUtil.lerpAngle(a.lat(), b.lat(), t),
						MathUtil.lerpAngle(a.lng(), b.lng(), t)
					);
				}
				static distance(a, b) {
					const dx = MathUtil.deltaAngle(a.lat(), a.lat());
					const dy = MathUtil.deltaAngle(a.lng(), b.lng());
					const distance = Math.sqrt(dx * dx + dy * dy);
					return distance;
				}
			}
			// 180, -180 

			class BulletHome {
				constructor() {
					this.fireInterval = Time.secToTime(0.5);
					this.fireTime = 0;
				}
			}

			class Vector2 {
				constructor(x, y) {
					this.x = x || 0;
					this.y = y || 0;
				}

				copyFrom(other) {
					this.x = other.x;
					this.y = other.y;
				}

				toLatLng() {
					return new google.maps.LatLng(this.y, this.x);
				}
			}

			class Bullet {
				constructor(startPosition, targetPosition) {
					this.position = startPosition;
					this.startPosition = startPosition;
					this.targetPosition = targetPosition;

					const distance = LatLngUtil.distance(targetPosition, startPosition);

					this.time = 0;
					this.duration = Time.secToTime(distance / 160);
					this.state = '';
					this.positionArr = [
						startPosition,
						startPosition,
					];
				}
			}

			class RandomUtil {
				static sign() {
					return (Math.random() < 0.5) ? -1 : 1;
				}
			}

			class App {
				constructor() {
					this.config = {
						fps: 20,
					};

					this.homePosition = new google.maps.LatLng(35.6811673, 139.7670516);

					const latLng = this.homePosition;
					const options = {
						zoom: 4,
						center: latLng,
						mapTypeId: 'satellite',
						clickableIcons: false,
						disableDefaultUI: true,
					};
					this.info = document.getElementById('info');
					this.map = new google.maps.Map(document.getElementById('map'), options);
					this.ticker = new Ticker();
					this.polylineArr = [];
					this.bulletArr = [];
					this.bulletHome = new BulletHome();
				}

				static loop(app) {
					{
						const arr = app.polylineArr;
						arr.forEach(_item => {
							_item.setMap(null);
						});
						arr.splice(0, arr.length);
					}

					{
						const bulletHome = app.bulletHome;
						if (bulletHome.fireInterval <= bulletHome.fireTime) {
							bulletHome.fireTime = 0;
							const latOffset = RandomUtil.sign() * (10 + Math.random() * 90);
							const lngOffset = RandomUtil.sign() * (10 + Math.random() * 90);

							const latOffset2 = RandomUtil.sign() * (Math.random() * 3);
							const lngOffset2 = RandomUtil.sign() * (Math.random() * 3);

							// 1, 0
							// -1 + (Math.random() * 2)

							const bullet = new Bullet(
								new google.maps.LatLng(app.homePosition.lat() + latOffset, app.homePosition.lng() + lngOffset),
								new google.maps.LatLng(app.homePosition.lat() + latOffset2, app.homePosition.lng() + lngOffset2)
							);
							app.bulletArr.push(bullet);
						}
						bulletHome.fireTime += app.ticker.deltaTime;
					}

					app.info.innerHTML = `bullet: ${app.bulletArr.length}`;

					{
						app.bulletArr.forEach(bullet => {
							const progress = MathUtil.progress01(bullet.time, bullet.duration);
							bullet.time += app.ticker.deltaTime;
							const nextPos = LatLngUtil.lerp(bullet.startPosition, bullet.targetPosition, progress);
							bullet.position = nextPos;
							bullet.positionArr.push(nextPos);
							
							const flightPlanCoordinates = [];
							{
								const arr = bullet.positionArr;
								arr.forEach(_item => flightPlanCoordinates.push(_item));
								const limit = 4;
								if (limit < arr.length) {
									arr.splice(0, arr.length - limit);
								}
							}

							const polyline = new google.maps.Polyline({
								path: flightPlanCoordinates,
								strokeColor: "#ffffff",
								strokeOpacity: 1.0,
								strokeWeight: 2
							});
							polyline.setMap(app.map);
							app.polylineArr.push(polyline);
						});

						// 廃棄
						{
							const bulletArr = app.bulletArr;
							for (let i = bulletArr.length - 1; 0 <= i; i--) {
								const bullet = bulletArr[i];
								if (bullet.time < bullet.duration) continue;
								bulletArr.splice(i, 1);
							}
						}
					}

					const deltaTime = Math.max(1, Time.secToTime(1 / app.config.fps));
					app.ticker = Ticker.next(app.ticker, deltaTime);

					setTimeout(App.loop, deltaTime, app);
				}
			}

			const app = new App();

			App.loop(app);

		</script>

	</body>
</html>
